<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Archives: 2015 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/archives/2015/">
<meta property="og:site_name" content="Hexo">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description">

  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">

  

  <script src="http://libs.baidu.com/jquery/1.9.0/jquery.js"></script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<div class="profilepic">
			<img src="https://avatars1.githubusercontent.com/u/10288803?v=3&amp;s=460">
		</div>

		<hgroup>
		  <h1 class="header-author"><a href="/">太急娃娃</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="/#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/#" title="rss">rss</a>
					        
								<a class="facebook" target="_blank" href="/#" title="facebook">facebook</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">奥巴马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">卡卡的美丽传说</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">本泽马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">吉格斯的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">习大大大不同</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">托蒂的博客</a>
			        
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					恰如猛虎卧荒丘 潜伏爪牙忍受.
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay"></div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img src="https://avatars1.githubusercontent.com/u/10288803?v=3&amp;s=460">
			</div>

			<hgroup>
			  <h1 class="header-author"><a href="/">太急娃娃</a></h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="/#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/#" title="rss">rss</a>
			        
						<a class="facebook" target="_blank" href="/#" title="facebook">facebook</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      
  
    <article id="post-图层几何学" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/01/28/图层几何学/" class="article-date">
  	<time datetime="2015-01-28T11:33:27.000Z" itemprop="datePublished">Jan 28 2015</time>
</a>
      
      
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="图层几何学">图层几何学</h1>
<blockquote>
<p><em>不熟悉几何学的人就不要来这里了</em> —柏拉图学院入口的签名</p>
</blockquote>
<p>在第二章里面，我们介绍了图层背后的图片，和一些控制图层坐标和旋转的属性。在这一章中，我们将要看一看图层内部是如何根据父图层和兄弟图层来控制位置和尺寸的。另外我们也会涉及如何管理图层的几何结构，以及它是如何被自动调整和自动布局影响的。</p>
<h2 id="布局">布局</h2>
<p><code>UIView</code>有三个比较重要的布局属性：<code>frame</code>，<code>bounds</code>和<code>center</code>，<code>CALayer</code>对应地叫做<code>frame</code>，<code>bounds</code>和<code>position</code>。为了能清楚区分，图层用了“position”，视图用了“center”，但是他们都代表同样的值。</p>
<p><code>frame</code>代表了图层的外部坐标（也就是在父图层上占据的空间），<code>bounds</code>是内部坐标（{0, 0}通常是图层的左上角），<code>center</code>和<code>position</code>都代表了相对于父图层<code>anchorPoint</code>所在的位置。<code>anchorPoint</code>的属性将会在后续介绍到，现在把它想成图层的中心点就好了。图3.1显示了这些属性是如何相互依赖的。</p>
<p><img src="./3.1.jpeg" alt="图3.1" title="图3.1" width="700"></p>
<p>图3.1 <code>UIView</code>和<code>CALayer</code>的坐标系</p>
<p>视图的<code>frame</code>，<code>bounds</code>和<code>center</code>属性仅仅是<em>存取方法</em>，当操纵视图的<code>frame</code>，实际上是在改变位于视图下方<code>CALayer</code>的<code>frame</code>，不能够独立于图层之外改变视图的<code>frame</code>。</p>
<p>对于视图或者图层来说，<code>frame</code>并不是一个非常清晰的属性，它其实是一个虚拟属性，是根据<code>bounds</code>，<code>position</code>和<code>transform</code>计算而来，所以当其中任何一个值发生改变，frame都会变化。相反，改变frame的值同样会影响到他们当中的值</p>
<p>记住当对图层做变换的时候，比如旋转或者缩放，<code>frame</code>实际上代表了覆盖在图层旋转之后的整个轴对齐的矩形区域，也就是说<code>frame</code>的宽高可能和<code>bounds</code>的宽高不再一致了（图3.2）</p>
<p><img src="./3.2.jpeg" alt="图3.2" title="图3.2" width="700"></p>
<p>图3.2 旋转一个视图或者图层之后的<code>frame</code>属性</p>
<h2 id="锚点">锚点</h2>
<p>之前提到过，视图的<code>center</code>属性和图层的<code>position</code>属性都指定了<code>anchorPoint</code>相对于父图层的位置。图层的<code>anchorPoint</code>通过<code>position</code>来控制它的<code>frame</code>的位置，你可以认为<code>anchorPoint</code>是用来移动图层的<em>把柄</em>。</p>
<p>默认来说，<code>anchorPoint</code>位于图层的中点，所以图层的将会以这个点为中心放置。<code>anchorPoint</code>属性并没有被<code>UIView</code>接口暴露出来，这也是视图的position属性被叫做“center”的原因。但是图层的<code>anchorPoint</code>可以被移动，比如你可以把它置于图层<code>frame</code>的左上角，于是图层的内容将会向右下角的<code>position</code>方向移动（图3.3），而不是居中了。</p>
<p><img src="./3.3.jpeg" alt="图3.3" title="图3.3" width="700"></p>
<p>图3.3 改变<code>anchorPoint</code>的效果</p>
<p>和第二章提到的<code>contentsRect</code>和<code>contentsCenter</code>属性类似，<code>anchorPoint</code>用<em>单位坐标</em>来描述，也就是图层的相对坐标，图层左上角是{0, 0}，右下角是{1, 1}，因此默认坐标是{0.5, 0.5}。<code>anchorPoint</code>可以通过指定x和y值小于0或者大于1，使它放置在图层范围之外。</p>
<p>注意在图3.3中，当改变了<code>anchorPoint</code>，<code>position</code>属性保持固定的值并没有发生改变，但是<code>frame</code>却移动了。</p>
<p>那在什么场合需要改变<code>anchorPoint</code>呢？既然我们可以随意改变图层位置，那改变<code>anchorPoint</code>不会造成困惑么？为了举例说明，我们来举一个实用的例子，创建一个模拟闹钟的项目。</p>
<p>钟面和钟表由四张图片组成（图3.4），为了简单说明，我们还是用传统的方式来装载和加载图片，使用四个<code>UIImageView</code>实例（当然你也可以用正常的视图，设置他们图层的<code>contents</code>图片）。</p>
<p><img src="./3.4.jpeg" alt="图3.4" title="图3.4" width="700"></p>
<p>图3.4 组成钟面和钟表的四张图片</p>
<p>闹钟的组件通过IB来排列（图3.5），这些图片视图嵌套在一个容器视图之内，并且自动调整和自动布局都被禁用了。这是因为自动调整会影响到视图的<code>frame</code>，而根据图3.2的演示，当视图旋转的时候，<code>frame</code>是会发生改变的，这将会导致一些布局上的失灵。</p>
<p>我们用<code>NSTimer</code>来更新闹钟，使用视图的<code>transform</code>属性来旋转钟表（如果你对这个属性不太熟悉，不要着急，我们将会在第5章“变换”当中详细说明），具体代码见清单3.1</p>
<p><img src="./3.5.jpeg" alt="图3.5" title="图3.5" width="700"></p>
<p>图3.5 在Interface Builder中布局闹钟视图</p>
<p>清单3.1 <strong>Clock</strong></p>
<figure class="highlight objective-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIImageView</span> *hourHand;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIImageView</span> *minuteHand;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIImageView</span> *secondHand;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) NSTimer *timer;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad</div><div class="line">{</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">//start timer</span></div><div class="line">    <span class="keyword">self</span><span class="variable">.timer</span> = [NSTimer scheduledTimerWithTimeInterval:<span class="number">1.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(tick) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</div><div class="line">                  ￼</div><div class="line">    <span class="comment">//set initial hand positions</span></div><div class="line">    [<span class="keyword">self</span> tick];</div><div class="line">}</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)tick</div><div class="line">{</div><div class="line">    <span class="comment">//convert time to hours, minutes and seconds</span></div><div class="line">    <span class="built_in">NSCalendar</span> *calendar = [[<span class="built_in">NSCalendar</span> alloc] initWithCalendarIdentifier:NSGregorianCalendar];</div><div class="line">    NSUInteger units = NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit;</div><div class="line">    NSDateComponents *components = [calendar components:units fromDate:[<span class="built_in">NSDate</span> date]];</div><div class="line">    <span class="built_in">CGFloat</span> hoursAngle = (components<span class="variable">.hour</span> / <span class="number">12.0</span>) * M_PI * <span class="number">2.0</span>;</div><div class="line">    <span class="comment">//calculate hour hand angle //calculate minute hand angle</span></div><div class="line">    <span class="built_in">CGFloat</span> minsAngle = (components<span class="variable">.minute</span> / <span class="number">60.0</span>) * M_PI * <span class="number">2.0</span>;</div><div class="line">    <span class="comment">//calculate second hand angle</span></div><div class="line">    <span class="built_in">CGFloat</span> secsAngle = (components<span class="variable">.second</span> / <span class="number">60.0</span>) * M_PI * <span class="number">2.0</span>;</div><div class="line">    <span class="comment">//rotate hands</span></div><div class="line">    <span class="keyword">self</span><span class="variable">.hourHand</span><span class="variable">.transform</span> = CGAffineTransformMakeRotation(hoursAngle);</div><div class="line">    <span class="keyword">self</span><span class="variable">.minuteHand</span><span class="variable">.transform</span> = CGAffineTransformMakeRotation(minsAngle);</div><div class="line">    <span class="keyword">self</span><span class="variable">.secondHand</span><span class="variable">.transform</span> = CGAffineTransformMakeRotation(secsAngle);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>

<p>运行项目，看起来有点奇怪（图3.6），因为钟表的图片在围绕着中心旋转，这并不是我们期待的一个支点。</p>
<p><img src="./3.6.jpeg" alt="图3.6" title="图3.6" width="700"></p>
<p>图3.6 钟面，和不对齐的钟指针</p>
<p>你也许会认为可以在Interface Builder当中调整指针图片的位置来解决，但其实并不能达到目的，因为如果不放在钟面中间的话，同样不能正确的旋转。</p>
<p>也许在图片末尾添加一个透明空间也是个解决方案，但这样会让图片变大，也会消耗更多的内存，这样并不优雅。</p>
<p>更好的方案是使用<code>anchorPoint</code>属性，我们来在<code>-viewDidLoad</code>方法中添加几行代码来给每个钟指针的<code>anchorPoint</code>做一些平移（清单3.2），图3.7显示了正确的结果。</p>
<p>清单3.2</p>
<figure class="highlight objective-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad </div><div class="line">{</div><div class="line">    [super viewDidLoad];</div><div class="line">    <span class="comment">// adjust anchor points</span></div><div class="line"></div><div class="line">    self.secondHand.layer.anchorPoint = CGPointMake(<span class="number">0.5f</span>, <span class="number">0.9f</span>); </div><div class="line">    self.minuteHand.layer.anchorPoint = CGPointMake(<span class="number">0.5f</span>, <span class="number">0.9f</span>); </div><div class="line">    self.hourHand.layer.anchorPoint = CGPointMake(<span class="number">0.5f</span>, <span class="number">0.9f</span>);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// start timer</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p><img src="./3.7.jpeg" alt="图3.7" title="图3.7" width="700"></p>
<p>图3.7 钟面，和正确对齐的钟指针</p>
<h2 id="坐标系">坐标系</h2>
<p>和视图一样，图层在图层树当中也是相对于父图层按层级关系放置，一个图层的<code>position</code>依赖于它父图层的<code>bounds</code>，如果父图层发生了移动，它的所有子图层也会跟着移动。</p>
<p>这样对于放置图层会更加方便，因为你可以通过移动根图层来将它的子图层作为一个整体来移动，但是有时候你需要知道一个图层的<em>绝对</em>位置，或者是相对于另一个图层的位置，而不是它当前父图层的位置。</p>
<p><code>CALayer</code>给不同坐标系之间的图层转换提供了一些工具类方法：</p>
<pre><code><span class="pp">- <span class="params">(<span class="variable">CGPoint</span>)</span>convertPoint:<span class="params">(<span class="variable">CGPoint</span>)</span>point fromLayer:<span class="params">(<span class="variable">CALayer</span> *)</span>layer; 
- <span class="params">(<span class="variable">CGPoint</span>)</span>convertPoint:<span class="params">(<span class="variable">CGPoint</span>)</span>point toLayer:<span class="params">(<span class="variable">CALayer</span> *)</span>layer; 
- <span class="params">(<span class="variable">CGRect</span>)</span>convertRect:<span class="params">(<span class="variable">CGRect</span>)</span>rect fromLayer:<span class="params">(<span class="variable">CALayer</span> *)</span>layer;
- <span class="params">(<span class="variable">CGRect</span>)</span>convertRect:<span class="params">(<span class="variable">CGRect</span>)</span>rect toLayer:<span class="params">(<span class="variable">CALayer</span> *)</span>layer;</span>
</code></pre><p>这些方法可以把定义在一个图层坐标系下的点或者矩形转换成另一个图层坐标系下的点或者矩形</p>
<h3 id="翻转的几何结构">翻转的几何结构</h3>
<p>常规说来，在iOS上，一个图层的<code>position</code>位于父图层的左上角，但是在Mac OS上，通常是位于左下角。Core Animation可以通过<code>geometryFlipped</code>属性来适配这两种情况，它决定了一个图层的坐标是否相对于父图层垂直翻转，是一个<code>BOOL</code>类型。在iOS上通过设置它为<code>YES</code>意味着它的子图层将会被垂直翻转，也就是将会沿着底部排版而不是通常的顶部（它的所有子图层也同理，除非把它们的<code>geometryFlipped</code>属性也设为<code>YES</code>）。</p>
<h3 id="Z坐标轴">Z坐标轴</h3>
<p>和<code>UIView</code>严格的二维坐标系不同，<code>CALayer</code>存在于一个三维空间当中。除了我们已经讨论过的<code>position</code>和<code>anchorPoint</code>属性之外，<code>CALayer</code>还有另外两个属性，<code>zPosition</code>和<code>anchorPointZ</code>，二者都是在Z轴上描述图层位置的浮点类型。</p>
<p>注意这里并没有更<em>深</em>的属性来描述由宽和高做成的<code>bounds</code>了，图层是一个完全扁平的对象，你可以把它们想象成类似于一页二维的坚硬的纸片，用胶水粘成一个空洞，就像三维结构的折纸一样。</p>
<p><code>zPosition</code>属性在大多数情况下其实并不常用。在第五章，我们将会涉及<code>CATransform3D</code>，你会知道如何在三维空间移动和旋转图层，除了做变换之外，<code>zPosition</code>最实用的功能就是改变图层的<em>显示顺序</em>了。</p>
<p>通常，图层是根据它们子图层的<code>sublayers</code>出现的顺序来类绘制的，这就是所谓的<em>画家的算法</em>—就像一个画家在墙上作画—后被绘制上的图层将会遮盖住之前的图层，但是通过增加图层的<code>zPosition</code>，就可以把图层向相机方向<em>前置</em>，于是它就在所有其他图层的<em>前面</em>了（或者至少是小于它的<code>zPosition</code>值的图层的前面）。</p>
<p>这里所谓的“相机”实际上是相对于用户是视角，这里和iPhone背后的内置相机没任何关系。</p>
<p>图3.8显示了在Interface Builder内的一对视图，正如你所见，首先出现在视图层级绿色的视图被绘制在红色视图的后面。</p>
<p><img src="./3.8.jpeg" alt="图3.8" title="图3.8" width="700"></p>
<p>图3.8 在视图层级中绿色视图被绘制在红色视图的后面</p>
<p>我们希望在真实的应用中也能显示出绘图的顺序，同样地，如果我们提高绿色视图的<code>zPosition</code>（清单3.3），我们会发现顺序就反了（图3.9）。其实并不需要增加太多，视图都非常地薄，所以给<code>zPosition</code>提高一个像素就可以让绿色视图前置，当然0.1或者0.0001也能够做到，但是最好不要这样，因为浮点类型四舍五入的计算可能会造成一些不便的麻烦。</p>
<p>清单3.3</p>
<figure class="highlight objective-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *greenView;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *redView;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad</div><div class="line">{</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    ￼</div><div class="line">    <span class="comment">//move the green view zPosition nearer to the camera</span></div><div class="line">    <span class="keyword">self</span><span class="variable">.greenView</span><span class="variable">.layer</span><span class="variable">.zPosition</span> = <span class="number">1.0</span>f;</div><div class="line">}</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>

<p><img src="./3.9.jpeg" alt="图3.9" title="图3.9" width="700"></p>
<p>图3.9 绿色视图被绘制在红色视图的前面</p>
<h2 id="Hit_Testing">Hit Testing</h2>
<p>第一章“图层树”证实了最好使用图层相关视图，而不是创建独立的图层关系。其中一个原因就是要处理额外复杂的触摸事件。</p>
<p><code>CALayer</code>并不关心任何响应链事件，所以不能直接处理触摸事件或者手势。但是它有一系列的方法帮你处理事件：<code>-containsPoint:</code>和<code>-hitTest:</code>。</p>
<p><code>-containsPoint:</code>接受一个在本图层坐标系下的<code>CGPoint</code>，如果这个点在图层<code>frame</code>范围内就返回<code>YES</code>。如清单3.4所示第一章的项目的另一个合适的版本，也就是使用<code>-containsPoint:</code>方法来判断到底是白色还是蓝色的图层被触摸了<br>（图3.10）。这需要把触摸坐标转换成每个图层坐标系下的坐标，结果很不方便。</p>
<p>清单3.4 使用containsPoint判断被点击的图层</p>
<figure class="highlight objective-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *layerView;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) CALayer *blueLayer;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad</div><div class="line">{</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">//create sublayer</span></div><div class="line">    <span class="keyword">self</span><span class="variable">.blueLayer</span> = [CALayer layer];</div><div class="line">    <span class="keyword">self</span><span class="variable">.blueLayer</span><span class="variable">.frame</span> = CGRectMake(<span class="number">50.0</span>f, <span class="number">50.0</span>f, <span class="number">100.0</span>f, <span class="number">100.0</span>f);</div><div class="line">    <span class="keyword">self</span><span class="variable">.blueLayer</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> blueColor]<span class="variable">.CGColor</span>;</div><div class="line">    <span class="comment">//add it to our view</span></div><div class="line">    [<span class="keyword">self</span><span class="variable">.layerView</span><span class="variable">.layer</span> addSublayer:<span class="keyword">self</span><span class="variable">.blueLayer</span>];</div><div class="line">}</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(UIEvent *)event</div><div class="line">{</div><div class="line">    <span class="comment">//get touch position relative to main view</span></div><div class="line">    <span class="built_in">CGPoint</span> point = [[touches anyObject] locationInView:<span class="keyword">self</span><span class="variable">.view</span>];</div><div class="line">    <span class="comment">//convert point to the white layer's coordinates</span></div><div class="line">    point = [<span class="keyword">self</span><span class="variable">.layerView</span><span class="variable">.layer</span> convertPoint:point fromLayer:<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.layer</span>];</div><div class="line">    <span class="comment">//get layer using containsPoint:</span></div><div class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span><span class="variable">.layerView</span><span class="variable">.layer</span> containsPoint:point]) {</div><div class="line">        <span class="comment">//convert point to blueLayer’s coordinates</span></div><div class="line">        point = [<span class="keyword">self</span><span class="variable">.blueLayer</span> convertPoint:point fromLayer:<span class="keyword">self</span><span class="variable">.layerView</span><span class="variable">.layer</span>];</div><div class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span><span class="variable">.blueLayer</span> containsPoint:point]) {</div><div class="line">            [[[UIAlertView alloc] initWithTitle:<span class="string">@"Inside Blue Layer"</span> </div><div class="line">                                        message:<span class="literal">nil</span></div><div class="line">                                       delegate:<span class="literal">nil</span> </div><div class="line">                              cancelButtonTitle:<span class="string">@"OK"</span></div><div class="line">                              otherButtonTitles:<span class="literal">nil</span>] show];</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            [[[UIAlertView alloc] initWithTitle:<span class="string">@"Inside White Layer"</span></div><div class="line">                                        message:<span class="literal">nil</span> </div><div class="line">                                       delegate:<span class="literal">nil</span></div><div class="line">                              cancelButtonTitle:<span class="string">@"OK"</span></div><div class="line">                              otherButtonTitles:<span class="literal">nil</span>] show];</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>

<p><img src="./3.10.jpeg" alt="图3.10" title="图3.10" width="700"></p>
<p>图3.10 点击图层被正确标识</p>
<p><code>-hitTest:</code>方法同样接受一个<code>CGPoint</code>类型参数，而不是<code>BOOL</code>类型，它返回图层本身，或者包含这个坐标点的叶子节点图层。这意味着不再需要像使用<code>-containsPoint:</code>那样，人工地在每个子图层变换或者测试点击的坐标。如果这个点在最外面图层的范围之外，则返回nil。具体使用<code>-hitTest:</code>方法被点击图层的代码如清单3.5所示。</p>
<p>清单3.5 使用hitTest判断被点击的图层</p>
<figure class="highlight objective-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(UIEvent *)event</div><div class="line">{</div><div class="line">    <span class="comment">//get touch position</span></div><div class="line">    <span class="built_in">CGPoint</span> point = [[touches anyObject] locationInView:<span class="keyword">self</span><span class="variable">.view</span>];</div><div class="line">    <span class="comment">//get touched layer</span></div><div class="line">    CALayer *layer = [<span class="keyword">self</span><span class="variable">.layerView</span><span class="variable">.layer</span> hitTest:point];</div><div class="line">    <span class="comment">//get layer using hitTest</span></div><div class="line">    <span class="keyword">if</span> (layer == <span class="keyword">self</span><span class="variable">.blueLayer</span>) {</div><div class="line">        [[[UIAlertView alloc] initWithTitle:<span class="string">@"Inside Blue Layer"</span></div><div class="line">                                    message:<span class="literal">nil</span></div><div class="line">                                   delegate:<span class="literal">nil</span></div><div class="line">                          cancelButtonTitle:<span class="string">@"OK"</span></div><div class="line">                          otherButtonTitles:<span class="literal">nil</span>] show];</div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (layer == <span class="keyword">self</span><span class="variable">.layerView</span><span class="variable">.layer</span>) {</div><div class="line">        [[[UIAlertView alloc] initWithTitle:<span class="string">@"Inside White Layer"</span></div><div class="line">                                    message:<span class="literal">nil</span></div><div class="line">                                   delegate:<span class="literal">nil</span></div><div class="line">                          cancelButtonTitle:<span class="string">@"OK"</span></div><div class="line">                          otherButtonTitles:<span class="literal">nil</span>] show];</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>注意当调用图层的<code>-hitTest:</code>方法时，测算的顺序严格依赖于图层树当中的图层顺序（和UIView处理事件类似）。之前提到的<code>zPosition</code>属性可以明显改变屏幕上图层的顺序，但不能改变事件传递的顺序。</p>
<p>这意味着如果改变了图层的z轴顺序，你会发现将不能够检测到最前方的视图点击事件，这是因为被另一个图层遮盖住了，虽然它的<code>zPosition</code>值较小，但是在图层树中的顺序靠前。我们将在第五章详细讨论这个问题。</p>
<h2 id="自动布局">自动布局</h2>
<p>你可能用过<code>UIViewAutoresizingMask</code>类型的一些常量，应用于当父视图改变尺寸的时候，相应<code>UIView</code>的<code>frame</code>也跟着更新的场景（通常用于横竖屏切换）。</p>
<p>在iOS6中，苹果介绍了<em>自动排版</em>机制，它和自动调整不同，并且更加复杂。</p>
<p>在Mac OS平台，<code>CALayer</code>有一个叫做<code>layoutManager</code>的属性可以通过<code>CALayoutManager</code>协议和<code>CAConstraintLayoutManager</code>类来实现自动排版的机制。但由于某些原因，这在iOS上并不适用。</p>
<p>当使用视图的时候，可以充分利用<code>UIView</code>类接口暴露出来的<code>UIViewAutoresizingMask</code>和<code>NSLayoutConstraint</code>API，但如果想随意控制<code>CALayer</code>的布局，就需要手工操作。最简单的方法就是使用<code>CALayerDelegate</code>如下函数：</p>
<pre><code><span class="pp">- <span class="params">(void)</span>layoutSublayersOfLayer:<span class="params">(<span class="variable">CALayer</span> *)</span>layer;</span>
</code></pre><p>当图层的<code>bounds</code>发生改变，或者图层的<code>-setNeedsLayout</code>方法被调用的时候，这个函数将会被执行。这使得你可以手动地重新摆放或者重新调整子图层的大小，但是不能像<code>UIView</code>的<code>autoresizingMask</code>和<code>constraints</code>属性做到自适应屏幕旋转。</p>
<p>这也是为什么最好使用视图而不是单独的图层来构建应用程序的另一个重要原因之一。</p>
<h2 id="总结">总结</h2>
<p>本章涉及了<code>CALayer</code>的集合结构，包括它的<code>frame</code>，<code>position</code>和<code>bounds</code>，介绍了三维空间内图层的概念，以及如何在独立的图层内响应事件，最后简单说明了在iOS平台，Core Animation对自动调整和自动布局支持的缺乏。</p>
<p>在第四章“视觉效果”当中，我们接着介绍一些图层外表的特性。</p>

      
    </div>
  </div>
  
</article>






  
    <article id="post-寄宿图" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/01/28/寄宿图/" class="article-date">
  	<time datetime="2015-01-28T11:33:22.000Z" itemprop="datePublished">Jan 28 2015</time>
</a>
      
      
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="寄宿图">寄宿图</h1>
<blockquote>
<p>图片胜过千言万语，界面抵得上千图片  ——Ben Shneiderman</p>
</blockquote>
<p>我们在第一章『图层树』中介绍了CALayer类并创建了一个简单的有蓝色背景的图层。背景颜色还好啦，但是如果它仅仅是展现了一个单调的颜色未免也太无聊了。事实上CALayer类能够包含一张你喜欢的图片，这一章节我们将来探索CALayer的寄宿图（即图层中包含的图）。</p>
<h2 id="contents属性">contents属性</h2>
<p>CALayer 有一个属性叫做<code>contents</code>，这个属性的类型被定义为id，意味着它可以是任何类型的对象。在这种情况下，你可以给<code>contents</code>属性赋任何值，你的app仍然能够编译通过。但是，在实践中，如果你给<code>contents</code>赋的不是CGImage，那么你得到的图层将是空白的。</p>
<p><code>contents</code>这个奇怪的表现是由Mac OS的历史原因造成的。它之所以被定义为id类型，是因为在Mac OS系统上，这个属性对CGImage和NSImage类型的值都起作用。如果你试图在iOS平台上将UIImage的值赋给它，只能得到一个空白的图层。一些初识Core Animation的iOS开发者可能会对这个感到困惑。</p>
<p>头疼的不仅仅是我们刚才提到的这个问题。事实上，你真正要赋值的类型应该是CGImageRef，它是一个指向CGImage结构的指针。UIImage有一个CGImage属性，它返回一个”CGImageRef”,如果你想把这个值直接赋值给CALayer的<code>contents</code>，那你将会得到一个编译错误。因为CGImageRef并不是一个真正的Cocoa对象，而是一个Core Foundation类型。</p>
<p>尽管Core Foundation类型跟Cocoa对象在运行时貌似很像（被称作toll-free bridging），他们并不是类型兼容的，不过你可以通过bridged关键字转换。如果要给图层的寄宿图赋值，你可以按照以下这个方法：</p>
<figure class="highlight objective-c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">layer.<span class="property">contents</span> = (__bridge <span class="property">id</span>)image.CGImage;</div></pre></td></tr></table></figure>

<p>如果你没有使用ARC（自动引用计数），你就不需要__bridge这部分。但是，你干嘛不用ARC？！</p>
<p>让我们来继续修改我们在第一章新建的工程，以便能够展示一张图片而不仅仅是一个背景色。我们已经用代码的方式建立一个图层，那我们就不需要额外的图层了。那么我们就直接把layerView的宿主图层的<code>contents</code>属性设置成图片。</p>
<p>清单2.1 更新后的代码。</p>
<figure class="highlight objective-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad</div><div class="line">{</div><div class="line">  [<span class="keyword">super</span> viewDidLoad]; <span class="comment">//load an image</span></div><div class="line">  <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"Snowman.png"</span>];</div><div class="line"></div><div class="line">  <span class="comment">//add it directly to our view's layer</span></div><div class="line">  <span class="keyword">self</span><span class="variable">.layerView</span><span class="variable">.layer</span><span class="variable">.contents</span> = (__bridge <span class="keyword">id</span>)image<span class="variable">.CGImage</span>;</div><div class="line">}</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>

<p>图表2.1 在UIView的宿主图层中显示一张图片</p>
<p><img src="./2.1.png" alt="图2.1"></p>
<p>我们用这些简单的代码做了一件很有趣的事情：我们利用CALayer在一个普通的UIView中显示了一张图片。这不是一个UIImageView，它不是我们通常用来展示图片的方法。通过直接操作图层，我们使用了一些新的函数，使得UIView更加有趣了。</p>
<p><strong>contentGravity</strong></p>
<p>你可能已经注意到了我们的雪人看起来有点。。。胖 ＝＝！ 我们加载的图片并不刚好是一个方的，为了适应这个视图，它有一点点被拉伸了。在使用UIImageView的时候遇到过同样的问题，解决方法就是把<code>contentMode</code>属性设置成更合适的值，像这样：</p>
<figure class="highlight objective-c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">view.contentMode </span>=<span class="string"> UIViewContentModeScaleAspectFit;</span></div></pre></td></tr></table></figure>

<p>这个方法基本和我们遇到的情况的解决方法已经接近了（你可以试一下 :) ），不过UIView大多数视觉相关的属性比如<code>contentMode</code>，对这些属性的操作其实是对对应图层的操作。</p>
<p>CALayer与<code>contentMode</code>对应的属性叫做<code>contentsGravity</code>，但是它是一个NSString类型，而不是像对应的UIKit部分，那里面的值是枚举。<code>contentsGravity</code>可选的常量值有以下一些：</p>
<ul>
<li>kCAGravityCenter</li>
<li>kCAGravityTop</li>
<li>kCAGravityBottom</li>
<li>kCAGravityLeft</li>
<li>kCAGravityRight</li>
<li>kCAGravityTopLeft</li>
<li>kCAGravityTopRight</li>
<li>kCAGravityBottomLeft</li>
<li>kCAGravityBottomRight</li>
<li>kCAGravityResize</li>
<li>kCAGravityResizeAspect</li>
<li>kCAGravityResizeAspectFill</li>
</ul>
<p>和<code>cotentMode</code>一样，<code>contentsGravity</code>的目的是为了决定内容在图层的边界中怎么对齐，我们将使用kCAGravityResizeAspect，它的效果等同于UIViewContentModeScaleAspectFit， 同时它还能在图层中等比例拉伸以适应图层的边界。</p>
<figure class="highlight objective-c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">self.layerView.layer.contentsGravity </span>=<span class="string"> kCAGravityResizeAspect;</span></div></pre></td></tr></table></figure>

<p>图2.2 可以看到结果</p>
<p><img src="./2.2.png" alt="image"></p>
<p>图2.2 正确地设置<code>contentsGravity</code>的值</p>
<h2 id="contentsScale">contentsScale</h2>
<p><code>contentsScale</code>属性定义了寄宿图的像素尺寸和视图大小的比例，默认情况下它是一个值为1.0的浮点数。</p>
<p><code>contentsScale</code>的目的并不是那么明显。它并不是总会对屏幕上的寄宿图有影响。如果你尝试对我们的例子设置不同的值，你就会发现根本没任何影响。因为<code>contents</code>由于设置了<code>contentsGravity</code>属性，所以它已经被拉伸以适应图层的边界。</p>
<p>如果你只是单纯地想放大图层的<code>contents</code>图片，你可以通过使用图层的<code>transform</code>和<code>affineTransform</code>属性来达到这个目的（见第五章『Transforms』，里面对此有解释），这(指放大)也不是<code>contengsScale</code>的目的所在.</p>
<p><code>contentsScale</code>属性其实属于支持高分辨率（又称Hi-DPI或Retina）屏幕机制的一部分。它用来判断在绘制图层的时候应该为寄宿图创建的空间大小，和需要显示的图片的拉伸度（假设并没有设置<code>contentsGravity</code>属性）。UIView有一个类似功能但是非常少用到的<code>contentScaleFactor</code>属性。</p>
<p>如果<code>contentsScale</code>设置为1.0，将会以每个点1个像素绘制图片，如果设置为2.0，则会以每个点2个像素绘制图片，这就是我们熟知的Retina屏幕。（如果你对像素和点的概念不是很清楚的话，这个章节的后面部分将会对此做出解释）。</p>
<p>这并不会对我们在使用kCAGravityResizeAspect时产生任何影响，因为它就是拉伸图片以适应图层而已，根本不会考虑到分辨率问题。但是如果我们把<code>contentsGravity</code>设置为kCAGravityCenter（这个值并不会拉伸图片），那将会有很明显的变化（如图2.3）</p>
<p><img src="./2.3.png" alt="图2.3"></p>
<p>图2.3 用错误的<code>contentsScale</code>属性显示Retina图片</p>
<p>如你所见，我们的雪人不仅有点大还有点像素的颗粒感。那是因为和UIImage不同，CGImage没有拉伸的概念。当我们使用UIImage类去读取我们的雪人图片的时候，他读取了高质量的Retina版本的图片。但是当我们用CGImage来设置我们的图层的内容时，拉伸这个因素在转换的时候就丢失了。不过我们可以通过手动设置<code>contentsScale</code>来修复这个问题（如2.2清单），图2.4是结果</p>
<figure class="highlight objective-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad</div><div class="line">{</div><div class="line">  [<span class="keyword">super</span> viewDidLoad]; <span class="comment">//load an image</span></div><div class="line">  <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"Snowman.png"</span>]; <span class="comment">//add it directly to our view's layer</span></div><div class="line">  <span class="keyword">self</span><span class="variable">.layerView</span><span class="variable">.layer</span><span class="variable">.contents</span> = (__bridge <span class="keyword">id</span>)image<span class="variable">.CGImage</span>; <span class="comment">//center the image</span></div><div class="line">  <span class="keyword">self</span><span class="variable">.layerView</span><span class="variable">.layer</span><span class="variable">.contentsGravity</span> = kCAGravityCenter;</div><div class="line"></div><div class="line">  <span class="comment">//set the contentsScale to match image</span></div><div class="line">  <span class="keyword">self</span><span class="variable">.layerView</span><span class="variable">.layer</span><span class="variable">.contentsScale</span> = image<span class="variable">.scale</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>

<p><img src="./2.4.png" alt="图2.4"></p>
<p>图2.4 同样的Retina图片设置了正确的<code>contentsScale</code>之后</p>
<p>当用代码的方式来处理寄宿图的时候，一定要记住要手动的设置图层的<code>contentsScale</code>属性，否则，你的图片在Retina设备上就显示得不正确啦。代码如下：</p>
<figure class="highlight objective-c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">layer.contentsScale </span>=<span class="string"> [UIScreen mainScreen].scale;</span></div></pre></td></tr></table></figure>

<h2 id="maskToBounds">maskToBounds</h2>
<p>现在我们的雪人总算是显示了正确的大小，不过你也许已经发现了另外一些事情：他超出了视图的边界。默认情况下，UIView仍然会绘制超过边界的内容或是子视图，在CALayer下也是这样的。</p>
<p>UIView有一个叫做<code>clipsToBounds</code>的属性可以用来决定是否显示超出边界的内容，CALayer对应的属性叫做<code>masksToBounds</code>，把它设置为YES，雪人就在边界里啦～（如图2.5）</p>
<p><img src="./2.5.png" alt="图2.5"></p>
<p>图2.5 使用<code>masksToBounds</code>来修建图层内容</p>
<h2 id="contentsRect">contentsRect</h2>
<p>CALayer的<code>contentsRect</code>属性允许我们在图层边框里显示寄宿图的一个子域。这涉及到图片是如何显示和拉伸的，所以要比<code>contentsGravity</code>灵活多了</p>
<p>和<code>bounds</code>，<code>frame</code>不同，<code>contentsRect</code>不是按点来计算的，它使用了<em>单位坐标</em>，单位坐标指定在0到1之间，是一个相对值（像素和点就是绝对值）。所以他们是相对与寄宿图的尺寸的。iOS使用了以下的坐标系统：</p>
<ul>
<li>点 —— 在iOS和Mac OS中最常见的坐标体系。点就像是虚拟的像素，也被称作逻辑像素。在标准设备上，一个点就是一个像素，但是在Retina设备上，一个点等于2*2个像素。iOS用点作为屏幕的坐标测算体系就是为了在Retina设备和普通设备上能有一致的视觉效果。</li>
<li>像素 —— 物理像素坐标并不会用来屏幕布局，但是仍然与图片有相对关系。UIImage是一个屏幕分辨率解决方案，所以指定点来度量大小。但是一些底层的图片表示如CGImage就会使用像素，所以你要清楚在Retina设备和普通设备上，他们表现出来了不同的大小。</li>
<li>单位 —— 对于与图片大小或是图层边界相关的显示，单位坐标是一个方便的度量方式， 当大小改变的时候，也不需要再次调整。单位坐标在OpenGL这种纹理坐标系统中用得很多，Core Animation中也用到了单位坐标。</li>
</ul>
<p>默认的<code>contentsRect</code>是{0, 0, 1, 1}，这意味着整个寄宿图默认都是可见的，如果我们指定一个小一点的矩形，图片就会被裁剪（如图2.6）</p>
<p><img src="./2.6.png" alt="图2.6"></p>
<p>图2.6 一个自定义的<code>contentsRect</code>（左）和之前显示的内容（右）</p>
<p>事实上给<code>contentsRect</code>设置一个负数的原点或是大于{1, 1}的尺寸也是可以的。这种情况下，最外面的像素会被拉伸以填充剩下的区域。</p>
<p><code>contentsRect</code>在app中最有趣的地方在于一个叫做<em>image sprites</em>（图片拼合）的用法。如果你有游戏编程的经验，那么你一定对图片拼合的概念很熟悉，图片能够在屏幕上独立地变更位置。抛开游戏编程不谈，这个技术常用来指代载入拼合的图片，跟移动图片一点关系也没有。</p>
<p>典型地，图片拼合后可以打包整合到一张大图上一次性载入。相比多次载入不同的图片，这样做能够带来很多方面的好处：内存使用，载入时间，渲染性能等等</p>
<p>2D游戏引擎入Cocos2D使用了拼合技术，它使用OpenGL来显示图片。不过我们可以使用拼合在一个普通的UIKit应用中，对！就是使用<code>contentsRect</code></p>
<p>首先，我们需要一个拼合后的图表 —— 一个包含小一些的拼合图的大图片。如图2.7所示：</p>
<p><img src="./2.7.png" alt="图2.7"></p>
<p>接下来，我们要在app中载入并显示这些拼合图。规则很简单：像平常一样载入我们的大图，然后把它赋值给四个独立的图层的<code>contents</code>，然后设置每个图层的<code>contentsRect</code>来去掉我们不想显示的部分。</p>
<p>我们的工程中需要一些额外的视图。（为了避免太多代码。我们将使用Interface Builder来拜访他们的位置，如果你愿意还是可以用代码的方式来实现的）。清单2.3有需要的代码，图2.8展示了结果</p>
<figure class="highlight objective-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *coneView;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *shipView;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *iglooView;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *anchorView;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)addSpriteImage:(<span class="built_in">UIImage</span> *)image withContentRect:(<span class="built_in">CGRect</span>)rect ￼toLayer:(CALayer *)layer <span class="comment">//set image</span></div><div class="line">{</div><div class="line">  layer<span class="variable">.contents</span> = (__bridge <span class="keyword">id</span>)image<span class="variable">.CGImage</span>;</div><div class="line"></div><div class="line">  <span class="comment">//scale contents to fit</span></div><div class="line">  layer<span class="variable">.contentsGravity</span> = kCAGravityResizeAspect;</div><div class="line"></div><div class="line">  <span class="comment">//set contentsRect</span></div><div class="line">  layer<span class="variable">.contentsRect</span> = rect;</div><div class="line">}</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad </div><div class="line">{</div><div class="line">  [<span class="keyword">super</span> viewDidLoad]; <span class="comment">//load sprite sheet</span></div><div class="line">  <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"Sprites.png"</span>];</div><div class="line">  <span class="comment">//set igloo sprite</span></div><div class="line">  [<span class="keyword">self</span> addSpriteImage:image withContentRect:CGRectMake(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>, <span class="number">0.5</span>) toLayer:<span class="keyword">self</span><span class="variable">.iglooView</span><span class="variable">.layer</span>];</div><div class="line">  <span class="comment">//set cone sprite</span></div><div class="line">  [<span class="keyword">self</span> addSpriteImage:image withContentRect:CGRectMake(<span class="number">0.5</span>, <span class="number">0</span>, <span class="number">0.5</span>, <span class="number">0.5</span>) toLayer:<span class="keyword">self</span><span class="variable">.coneView</span><span class="variable">.layer</span>];</div><div class="line">  <span class="comment">//set anchor sprite</span></div><div class="line">  [<span class="keyword">self</span> addSpriteImage:image withContentRect:CGRectMake(<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>) toLayer:<span class="keyword">self</span><span class="variable">.anchorView</span><span class="variable">.layer</span>];</div><div class="line">  <span class="comment">//set spaceship sprite</span></div><div class="line">  [<span class="keyword">self</span> addSpriteImage:image withContentRect:CGRectMake(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>) toLayer:<span class="keyword">self</span><span class="variable">.shipView</span><span class="variable">.layer</span>];</div><div class="line">}</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>

<p><img src="./2.8.png" alt="图2.8"></p>
<p>拼合不仅给app提供了一个整洁的载入方式，还有效地提高了载入性能（单张大图比多张小图载入地更快），但是如果有手动安排的话，他们还是有一些不方便的，如果你需要在一个已经创建好的品和图上做一些尺寸上的修改或者其他变动，无疑是比较麻烦的。</p>
<p>Mac上有一些商业软件可以为你自动拼合图片，这些工具自动生成一个包含拼合后的坐标的XML或者plist文件，拼合图片的使用大大简化。这个文件可以和图片一同载入，并给每个拼合的图层设置<code>contentsRect</code>，这样开发者就不用手动写代码来摆放位置了。</p>
<p>这些文件通常在OpenGL游戏中使用，不过呢，你要是有兴趣在一些常见的app中使用拼合技术，那么一个叫做LayerSprites的开源库（<a href="https://github.com/nicklockwood/LayerSprites" target="_blank" rel="external">https://github.com/nicklockwood/LayerSprites</a>)，它能够读取Cocos2D格式中的拼合图并在普通的Core Animation层中显示出来。</p>
<h2 id="contentsCenter">contentsCenter</h2>
<p>本章我们介绍的最后一个和内容有关的属性是<code>contentsCenter</code>，看名字你可能会以为它可能跟图片的位置有关，不过这名字着实误导了你。<code>contentsCenter</code>其实是一个CGRect，它定义了一个固定的边框和一个在图层上可拉伸的区域。 改变<code>contentsCenter</code>的值并不会影响到寄宿图的显示，除非这个图层的大小改变了，你才看得到效果。</p>
<p>默认情况下，<code>contentsCenter</code>是{0, 0, 1, 1}，这意味着如果大小（由<code>conttensGravity</code>决定）改变了,那么寄宿图将会均匀地拉伸开。但是如果我们增加原点的值并减小尺寸。我们会在图片的周围创造一个边框。图2.9展示了<code>contentsCenter</code>设置为{0.25, 0.25, 0.5, 0.5}的效果。</p>
<p><img src="./2.9.png" alt="图2.9"></p>
<p>图2.9 <code>contentsCenter</code>的例子</p>
<p>这意味着我们可以随意重设尺寸，边框仍然会是连续的。他工作起来的效果和UIImage里的-resizableImageWithCapInsets: 方法效果非常类似，只是它可以运用到任何寄宿图，甚至包括在Core Graphics运行时绘制的图形（本章稍后会讲到）。</p>
<p><img src="./2.10.png" alt="图2.10"></p>
<p>图2.10 同一图片使用不同的<code>contentsCenter</code></p>
<p>清单2.4 演示了如何编写这些可拉伸视图。不过，contentsCenter的另一个很酷的特性就是，它可以在Interface Builder里面配置，根本不用写代码。如图2.11</p>
<p>清单2.4 用<code>contentsCenter</code>设置可拉伸视图</p>
<figure class="highlight objective-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *button1;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *button2;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)addStretchableImage:(<span class="built_in">UIImage</span> *)image withContentCenter:(<span class="built_in">CGRect</span>)rect toLayer:(CALayer *)layer</div><div class="line">{  </div><div class="line">  <span class="comment">//set image</span></div><div class="line">  layer<span class="variable">.contents</span> = (__bridge <span class="keyword">id</span>)image<span class="variable">.CGImage</span>;</div><div class="line"></div><div class="line">  <span class="comment">//set contentsCenter</span></div><div class="line">  layer<span class="variable">.contentsCenter</span> = rect;</div><div class="line">}</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad</div><div class="line">{</div><div class="line">  [<span class="keyword">super</span> viewDidLoad]; <span class="comment">//load button image</span></div><div class="line">  <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"Button.png"</span>];</div><div class="line"></div><div class="line">  <span class="comment">//set button 1</span></div><div class="line">  [<span class="keyword">self</span> addStretchableImage:image withContentCenter:CGRectMake(<span class="number">0.25</span>, <span class="number">0.25</span>, <span class="number">0.5</span>, <span class="number">0.5</span>) toLayer:<span class="keyword">self</span><span class="variable">.button1</span><span class="variable">.layer</span>];</div><div class="line"></div><div class="line">  <span class="comment">//set button 2</span></div><div class="line">  [<span class="keyword">self</span> addStretchableImage:image withContentCenter:CGRectMake(<span class="number">0.25</span>, <span class="number">0.25</span>, <span class="number">0.5</span>, <span class="number">0.5</span>) toLayer:<span class="keyword">self</span><span class="variable">.button2</span><span class="variable">.layer</span>];</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>

<p><img src="./2.11.png" alt="图2.11"></p>
<p>图2.11 用Interface Builder 探测窗口控制<code>contentsCenter</code>属性</p>
<h2 id="Custome_Drawing">Custome Drawing</h2>
<p>给<code>contents</code>赋CGImage的值不是唯一的设置寄宿图的方法。我们也可以直接用Core Graphics直接绘制寄宿图。能够通过继承UIView并实现<code>-drawRect:</code>方法来自定义绘制。</p>
<p><code>-drawRect:</code> 方法没有默认的实现，因为对UIView来说，寄宿图并不是必须的，它不在意那到底是单调的颜色还是有一个图片的实例。如果UIView检测到<code>-drawRect:</code> 方法被调用了，它就会为视图分配一个寄宿图，这个寄宿图的像素尺寸等于视图大小乘以 <code>contentsScale</code>的值。</p>
<p>如果你不需要寄宿图，那就不要创建这个方法了，这会造成CPU资源和内存的浪费，这也是为什么苹果建议：如果没有自定义绘制的任务就不要在子类中写一个空的-drawRect:方法。</p>
<p>当视图在屏幕上出现的时候 <code>-drawRect:</code>方法就会被自动调用。<code>-drawRect:</code>方法里面的代码利用Core Graphics去绘制一个寄宿图，然后内容就会被缓存起来直到它需要被更新（通常是因为开发者调用了<code>-setNeedsDisplay</code>方法，尽管影响到表现效果的属性值被更改时，一些视图类型会被自动重绘，如<code>bounds</code>属性）。虽然<code>-drawRect:</code>方法是一个UIView方法，事实上都是底层的CALayer安排了重绘工作和保存了因此产生的图片。</p>
<p>CALayer有一个可选的<code>delegate</code>属性，实现了<code>CALayerDelegate</code>协议，当CALayer需要一个内容特定的信息时，就会从协议中请求。CALayerDelegate是一个非正式协议，其实就是说没有CALayerDelegate @protocol可以让你在类里面引用啦。你只需要调用你想调用的方法，CALayer会帮你做剩下的。（<code>delegate</code>属性被声明为id类型，所有的代理方法都是可选的）。</p>
<p>当需要被重绘时，CALayer会请求它的代理给他一个寄宿图来显示。它通过调用下面这个方法做到的:</p>
<figure class="highlight objective-c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">void</span>)displayLayer:(CALayerCALayer *)layer;</div></pre></td></tr></table></figure>

<p>趁着这个机会，如果代理想直接设置<code>contents</code>属性的话，它就可以这么做，不然没有别的方法可以调用了。如果代理不实现<code>-displayLayer:</code>方法，CALayer就会转而尝试调用下面这个方法：</p>
<figure class="highlight objective-c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="pp">- <span class="params">(void)</span>drawLayer:<span class="params">(<span class="variable">CALayer</span> *)</span>layer inContext:<span class="params">(<span class="variable">CGContextRef</span>)</span>ctx;</span></div></pre></td></tr></table></figure>

<p>在调用这个方法之前，CALayer创建了一个合适尺寸的空寄宿图（尺寸由<code>bounds</code>和<code>contentsScale</code>决定）和一个Core Graphics的绘制上下文环境，为绘制寄宿图做准备，他作为ctx参数传入。</p>
<p>让我们来继续第一章的项目让它实现CALayerDelegate并做一些绘图工作吧（见清单2.5）.图2.12是他的结果</p>
<p>清单2.5 实现CALayerDelegate</p>
<figure class="highlight objective-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad</div><div class="line">{</div><div class="line">  [<span class="keyword">super</span> viewDidLoad];</div><div class="line">  ￼</div><div class="line">  <span class="comment">//create sublayer</span></div><div class="line">  CALayer *blueLayer = [CALayer layer];</div><div class="line">  blueLayer<span class="variable">.frame</span> = CGRectMake(<span class="number">50.0</span>f, <span class="number">50.0</span>f, <span class="number">100.0</span>f, <span class="number">100.0</span>f);</div><div class="line">  blueLayer<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> blueColor]<span class="variable">.CGColor</span>;</div><div class="line"></div><div class="line">  <span class="comment">//set controller as layer delegate</span></div><div class="line">  blueLayer<span class="variable">.delegate</span> = <span class="keyword">self</span>;</div><div class="line"></div><div class="line">  <span class="comment">//ensure that layer backing image uses correct scale</span></div><div class="line">  blueLayer<span class="variable">.contentsScale</span> = [UIScreen mainScreen]<span class="variable">.scale</span>; <span class="comment">//add layer to our view</span></div><div class="line">  [<span class="keyword">self</span><span class="variable">.layerView</span><span class="variable">.layer</span> addSublayer:blueLayer];</div><div class="line"></div><div class="line">  <span class="comment">//force layer to redraw</span></div><div class="line">  [blueLayer display];</div><div class="line">}</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx</div><div class="line">{</div><div class="line">  <span class="comment">//draw a thick red circle</span></div><div class="line">  CGContextSetLineWidth(ctx, <span class="number">10.0</span>f); </div><div class="line">  CGContextSetStrokeColorWithColor(ctx, [<span class="built_in">UIColor</span> redColor]<span class="variable">.CGColor</span>);</div><div class="line">  CGContextStrokeEllipseInRect(ctx, layer<span class="variable">.bounds</span>);</div><div class="line">}</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>

<p><img src="./2.12.png" alt="图2.12"></p>
<p>图2.12 实现CALayerDelegate来绘制图层</p>
<p>注意一下一些有趣的事情：</p>
<ul>
<li>我们在blueLayer上显式地调用了<code>-display</code>。不同于UIView，当图层显示在屏幕上时，CALayer不会自动重绘它的内容。它把重绘的决定权交给了开发者。</li>
<li>尽管我们没有用<code>masksToBounds</code>属性，绘制的那个圆仍然沿边界被裁剪了。这是因为当你使用CALayerDelegate绘制寄宿图的时候，并没有对超出边界外的内容提供绘制支持。</li>
</ul>
<p>现在你理解了CALayerDelegate，并知道怎么使用它。但是除非你创建了一个单独的图层，你几乎没有机会用到CALayerDelegate协议。因为当UIView创建了它的宿主图层时，它就会自动地把图层的delegate设置为它自己，并提供了一个<code>-displayLayer:</code>的实现，那所有的问题就都没了。</p>
<p>当使用寄宿了视图的图层的时候，你也不必实现<code>-displayLayer:</code>和<code>-drawLayer:inContext:</code>方法来绘制你的寄宿图。通常做法是实现UIView的<code>-drawRect:</code>方法，UIView就会帮你做完剩下的工作，包括在需要重绘的时候调用<code>-display</code>方法。</p>
<h2 id="总结">总结</h2>
<p>本章介绍了寄宿图和一些相关的属性。你学到了如何显示和放置图片， 使用拼合技术来显示， 以及用CALayerDelegate和Core Graphics来绘制图层内容。</p>
<p>在第三章，”图层几何学”中，我们将会探讨一下图层的几何，观察他们是如何放置和改变相互的尺寸的。</p>

      
    </div>
  </div>
  
</article>






  
    <article id="post-图层树" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/01/28/图层树/" class="article-date">
  	<time datetime="2015-01-28T11:24:01.000Z" itemprop="datePublished">Jan 28 2015</time>
</a>
      
      
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="图层的树状结构">图层的树状结构</h1>
<blockquote>
<p>巨妖有图层，洋葱也有图层，你有吗？我们都有图层 — 史莱克</p>
</blockquote>
<p>Core Animation其实是一个令人误解的命名。你可能认为它只是用来做动画的，但实际上它是从一个叫做<em>Layer Kit</em>这么一个不怎么和动画有关的名字演变而来，所以做动画这只是Core Animation特性的冰山一角。</p>
<p>Core Animation是一个<em>复合引擎</em>，它的职责就是尽可能快地组合屏幕上不同的可视内容，这个内容是被分解成独立的<em>图层</em>，存储在一个叫做<em>图层树</em>的体系之中。于是这个树形成了<strong>UIKit</strong>以及在iOS应用程序当中你所能在屏幕上看见的一切的基础。</p>
<p>在我们讨论动画之前，我们将从图层树开始，涉及一下Core Animation的<em>静态</em>组合以及布局特性。</p>
<h2 id="图层和视图">图层和视图</h2>
<p>如果你曾经在iOS或者Mac OS平台上写过应用程序，你可能会对<em>视图</em>的概念比较熟悉。一个视图就是在屏幕上显示的一个矩形块（比如图片，文字或者视频），它能够拦截类似于鼠标点击或者触摸手势等用户输入。视图在层级关系中可以互相嵌套，一个视图可以管理它的所有子视图的位置。图1.1显示了一种典型的视图层级关系</p>
<p><img src="./1.1.jpeg" alt="图1.1" title="图1.1" width="700"></p>
<p>图1.1 一种典型的iOS屏幕（左边）和形成视图的层级关系（右边）</p>
<p>在iOS当中，所有的视图都从一个叫做<code>UIVIew</code>的基类派生而来，<code>UIView</code>可以处理触摸事件，可以支持基于<em>Core Graphics</em>绘图，可以做仿射变换（例如旋转或者缩放），或者简单的类似于滑动或者渐变的动画。</p>
<h3 id="CALayer">CALayer</h3>
<p><code>CALayer</code>类在概念上和<code>UIView</code>类似，同样也是一些被层级关系树管理的矩形块，同样也可以包含一些内容（像图片，文本或者背景色），管理子图层的位置。它们有一些方法和属性用来做动画和变换。和<code>UIView</code>最大的不同是<code>CALayer</code>不处理用户的交互。</p>
<p><code>CALayer</code>并不清楚具体的<em>响应链</em>（iOS通过视图层级关系用来传送触摸事件的机制），于是它并不能够响应事件，即使它提供了一些方法来判断是否一个触点在图层的范围之内（具体见第三章，“图层的几何学”）</p>
<h3 id="平行的层级关系">平行的层级关系</h3>
<p>每一个<code>UIview</code>都有一个<code>CALayer</code>实例的图层属性，也就是所谓的<em>backing layer</em>，视图的职责就是创建并管理这个图层，以确保当子视图在层级关系中添加或者被移除的时候，他们关联的图层也同样对应在层级关系树当中有相同的操作（见图1.2）。</p>
<p><img src="./1.2.jpeg" alt="图1.2" title="图1.2" width="700"></p>
<p>图1.2 图层的树状结构（左边）以及对应的视图层级（右边）</p>
<p>实际上这些背后关联的图层才是真正用来在屏幕上显示和做动画，<code>UIView</code>仅仅是对它的一个封装，提供了一些iOS类似于处理触摸的具体功能，以及Core Animation底层方法的高级接口。</p>
<p>但是为什么iOS要基于<code>UIView</code>和<code>CALayer</code>提供两个平行的层级关系呢？为什么不用一个简单的层级来处理所有事情呢？原因在于要做职责分离，这样也能避免很多重复代码。在iOS和Mac OS两个平台上，事件和用户交互有很多地方的不同，基于多点触控的用户界面和基于鼠标键盘有着本质的区别，这就是为什么iOS有UIKit和<code>UIView</code>，但是Mac OS有AppKit和<code>NSView</code>的原因。他们功能上很相似，但是在实现上有着显著的区别。</p>
<p>绘图，布局和动画，相比之下就是类似Mac笔记本和桌面系列一样应用于iPhone和iPad触屏的概念。把这种功能的逻辑分开并应用到独立的Core Animation框架，苹果就能够在iOS和Mac OS之间共享代码，使得对苹果自己的OS开发团队和第三方开发者去开发两个平台的应用更加便捷。</p>
<p>实际上，这里并不是两个层级关系，而是四个，每一个都扮演不同的角色，除了视图层级和图层树之外，还存在<em>呈现树</em>和<em>渲染树</em>，将在第七章“隐式动画”和第十二章“性能调优”分别讨论。</p>
<h2 id="图层的能力">图层的能力</h2>
<p>如果说<code>CALayer</code>是<code>UIView</code>内部实现细节，那我们为什么要全面地了解它呢？苹果当然为我们提供了优美简洁的<code>UIView</code>接口，那么我们是否就没必要直接去处理Core Animation的细节了呢？</p>
<p>某种意义上说的确是这样，对一些简单的需求来说，我们确实没必要处理<code>CALayer</code>，因为苹果已经通过<code>UIView</code>的高级API间接地使得动画变得很简单。</p>
<p>但是这种简单会不可避免地带来一些灵活上的缺陷。如果你略微想在底层做一些改变，或者使用一些苹果没有在<code>UIView</code>上实现的接口功能，这时除了介入Core Animation底层之外别无选择。</p>
<p>我们已经证实了图层不能像视图那样处理触摸事件，那么他能做哪些视图不能做的呢？这里有一些<code>UIView</code>没有暴露出来的CALayer的功能：</p>
<ul>
<li>阴影，圆角，带颜色的边框</li>
<li>3D变换</li>
<li>非矩形范围</li>
<li>透明遮罩</li>
<li>多级非线性动画</li>
</ul>
<p>我们将会在后续章节中探索这些功能，首先我们要关注一下在应用程序当中<code>CALayer</code>是怎样被利用起来的。</p>
<h2 id="使用图层">使用图层</h2>
<p>首先我们来创建一个简单的项目，来操纵一些<code>layer</code>的属性。打开Xcode，使用<em>Single View Application</em>模板创建一个工程。</p>
<p>在屏幕中央创建一个小视图（大约200 X 200的尺寸），当然你可以手工编码，或者使用Interface Builder（随你方便）。确保你的视图控制器要添加一个视图的属性以便可以直接访问它。我们把它称作<code>layerView</code>。</p>
<p>运行项目，应该能在浅灰色屏幕背景中看见一个白色方块（图1.3），如果没看见，可能需要调整一下背景window或者view的颜色</p>
<p><img src="./1.3.jpeg" alt="图1.3" title="图1.3" width="700"></p>
<p>图1.3 灰色背景上的一个白色<code>UIView</code></p>
<p>这并没有什么令人激动的地方，我们来添加一个色块，在白色方块中间添加一个小的蓝色块。</p>
<p>我们当然可以简单地在已经存在的<code>UIView</code>上添加一个子视图（随意用代码或者IB），但这不能真正学到任何关于图层的东西。</p>
<p>于是我们来创建一个<code>CALayer</code>，并且把它作为我们视图相关图层的子图层。尽管<code>UIView</code>类的接口中暴露了图层属性，但是标准的Xcode项目模板并没有包含Core Animation相关头文件。所以如果我们不给项目添加合适的库，是不能够使用任何图层相关的方法或者访问它的属性。所以首先需要添加QuartzCore框架到Build Phases标签（图1.4），然后在vc的.m文件中引入<quartzcore quartzcore.h="">库。</quartzcore></p>
<p><img src="./1.4.jpeg" alt="图1.4" title="图1.4" width="700"></p>
<p>图1.4 把QuartzCore库添加到项目</p>
<p>之后就可以在代码中直接引用<code>CALayer</code>的属性和方法。在清单1.1中，我们用创建了一个<code>CALayer</code>，设置了它的<code>backgroundColor</code>属性，然后添加到<code>layerView</code>背后相关图层的子图层（这段代码的前提是通过IB创建了<code>layerView</code>并做好了连接），图1.5显示了结果。</p>
<p>清单1.1 给视图添加一个蓝色子图层</p>
<figure class="highlight objective-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#import <span class="title">"ViewController.h"</span></span></div><div class="line"><span class="preprocessor">#import <span class="title">&lt;QuartzCore/QuartzCore.h&gt;</span></span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *layerView;</div><div class="line">￼</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad</div><div class="line">{</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">//create sublayer</span></div><div class="line">    CALayer *blueLayer = [CALayer layer];</div><div class="line">    blueLayer<span class="variable">.frame</span> = CGRectMake(<span class="number">50.0</span>f, <span class="number">50.0</span>f, <span class="number">100.0</span>f, <span class="number">100.0</span>f);</div><div class="line">    blueLayer<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> blueColor]<span class="variable">.CGColor</span>;</div><div class="line">    <span class="comment">//add it to our view</span></div><div class="line">    [<span class="keyword">self</span><span class="variable">.layerView</span><span class="variable">.layer</span> addSublayer:blueLayer];</div><div class="line">}</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>


<p><img src="./1.5.jpeg" alt="图1.5" title="图1.5" width="700"></p>
<p>图1.5 白色<code>UIView</code>内部嵌套的蓝色<code>CALayer</code></p>
<p>一个视图只有一个相关联的图层（自动创建），同时它也可以支持添加无数多个子图层，从清单1.1可以看出，你可以显示创建一个单独的图层，并且把它直接添加到视图关联图层的子图层。尽管可以这样添加图层，但往往我们只是见简单地处理视图，他们关联的图层并不需要额外地手动添加子图层。</p>
<p>在Mac OS平台，10.8版本之前，一个显著的性能缺陷就是由于用了视图层级而不是单独在一个视图内使用<code>CALayer</code>树状层级。但是在iOS平台，使用轻量级的<code>UIView</code>类并没有显著的性能影响（当然在Mac OS 10.8之后，<code>NSView</code>的性能同样也得到很大程度的提高）。</p>
<p>使用图层关联的视图而不是<code>CALayer</code>的好处在于，你能在使用所有<code>CALayer</code>底层特性的同时，也可以使用<code>UIView</code>的高级API（比如自动排版，布局和事件处理）。</p>
<p>然而，当满足以下条件的时候，你可能更需要使用<code>CALayer</code>而不是<code>UIView</code></p>
<ul>
<li>开发同时可以在Mac OS上运行的跨平台应用</li>
<li>使用多种<code>CALayer</code>的子类（见第六章，“特殊的图层“），并且不想创建额外的<code>UIView</code>去包封装它们所有</li>
<li>做一些对性能特别挑剔的工作，比如对<code>UIView</code>一些可忽略不计的操作都会引起显著的不同（尽管如此，你可能会直接想使用OpenGL绘图）</li>
</ul>
<p>但是这些例子都很少见，总的来说，处理视图会比单独处理图层更加方便。</p>
<h2 id="总结">总结</h2>
<p>这一章阐述了图层的树状结构，说明了如何在iOS中由<code>UIView</code>的层级关系形成的一种平行的<code>CALayer</code>层级关系，在后面的实验中，我们创建了自己的<code>CALayer</code>，并把它添加到图层树中。</p>
<p>在第二章，“图层关联的图片”，我们将要研究一下<code>CALayer</code>关联的图片，以及Core Animation提供的操作显示的一些特性。</p>

      
    </div>
  </div>
  
</article>






  
  

      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 太急娃娃
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">

  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>

  <script src="/js/main.js" type="text/javascript"></script>


  </div>
</body>
</html>